
@article{danos_linear_2001,
	title = {Linear Logic \& Elementary Time},
	volume = {183},
	abstract = {Introduction  Think of elementary linear logic as an idealized functional programming language with a severe typing mechanism. Definition by recursion is, of course, forbidden, but some sort of iteration still is possible and the purpose of this paper is to show that enough computing power remains so that elementary recursive functions can be implemented. Actually, the whole paper can be considered an exercise in programming elegantly with a rather desolate language.  To zero in on an interesting class of functions, one usually tries to weaken in the given logic whatever corresponds to induction or iteration. Here we're following a di\#erent strand, rather specific to the linear logic decomposition of the implication as {!A\#B}, by fiddling with the rules handling `!'. The standard rules are enough to embed the full power of intuitionistic computations. So the game is to find a sensible way to make them harder to use than in full linear logic. There ar},
	journal = {Information and Computation},
	author = {Danos, Vincent and Joinet, Jean-baptiste},
	year = {2001},
	pages = {2003}
},

@article{baillot_light_2011,
	title = {Light logics and optimal reduction: Completeness and complexity},
	volume = {209},
	shorttitle = {Light logics and optimal reduction},
	url = {http://dblp.uni-trier.de/rec/bibtex/journals/iandc/BaillotCL11},
	number = {2},
	urldate = {2014-01-23},
	journal = {Inf. Comput.},
	author = {Baillot, Patrick and Coppola, Paolo and Lago, Ugo Dal},
	year = {2011},
	pages = {118--142}
},

@article{baillot_linear_2010,
	title = {Linear logic by levels and bounded time complexity},
	volume = {411},
	url = {http://dblp.uni-trier.de/rec/bibtex/journals/tcs/BaillotM10},
	number = {2},
	urldate = {2014-01-23},
	journal = {Theor. Comput. Sci.},
	author = {Baillot, Patrick and Mazza, Damiano},
	year = {2010},
	pages = {470--503}
},

@article{baillot_elementary_2001,
	title = {Elementary Complexity and Geometry of Interaction},
	volume = {45},
	url = {http://dblp.uni-trier.de/rec/bibtex/journals/fuin/BaillotP01},
	number = {1-2},
	urldate = {2014-01-23},
	journal = {Fundam. Inform.},
	author = {Baillot, Patrick and Pedicini, Marco},
	year = {2001},
	pages = {1--31}
},

@article{seiller_logarithmic_2013,
	title			=	{Logarithmic Space and Permutations},
	journal		=	{Arxiv preprint},
	archivePrefix	=	{arXiv},
	volume		=	{abs/1301.3189},
	year			=	2013,
	eprint		=	{1301.3189}, 
	primaryClass	=	{cs.LO},
	author = {Seiller, Thomas and Aubert, Cl\'ement},
},

@article{aubert_characterizing_2012,
	title			=	{Characterizing co-NL by a group action},
	journal		=	{Arxiv preprint},
	year			=	{2012},
	volume		=	{abs/1209.3422},
	archivePrefix	=	{arXiv},
	eprint		=	{1209.3422},
	primaryClass	=	{cs.LO},
	author = {Aubert, Cl\'ement and Seiller, Thomas},
},

@inproceedings{gaboardi_logical_2008,
	title = {A logical account of pspace},
	url = {http://dblp.uni-trier.de/rec/bibtex/conf/popl/GaboardiMR08},
	urldate = {2014-01-29},
	author = {Gaboardi, Marco and Marion, Jean-Yves and Rocca, Simona Ronchi Della},
	year = {2008},
	pages = {121--131}
},

@inproceedings{schopp_stratified_2007,
	title = {Stratified Bounded Affine Logic for Logarithmic Space},
	url = {http://dblp.uni-trier.de/rec/bibtex/conf/lics/Schopp07},
	urldate = {2014-01-29},
	author = {Sch\"opp, Ulrich},
	year = {2007},
	pages = {411--420}
},

@article{hofmann_pure_2010,
	title = {Pure pointer programs with iteration},
	volume = {11},
	url = {http://dblp.uni-trier.de/rec/bibtex/journals/tocl/HofmannS10},
	number = {4},
	urldate = {2014-01-29},
	journal = {{ACM} Trans. Comput. Log.},
	author = {Hofmann, Martin and Sch\"opp, Ulrich},
	year = {2010}
},

@inproceedings{hofmann_pointer_2009,
	title = {Pointer Programs and Undirected Reachability},
	url = {http://dblp.uni-trier.de/rec/bibtex/conf/lics/HofmannS09},
	urldate = {2014-01-29},
	author = {Hofmann, Martin and Sch\"opp, Ulrich},
	year = {2009},
	pages = {133--142}
},

@inproceedings{ben-amram_what_1995,
	title = {What is a {"Pointer} Machine"?},
	abstract = {A {"Pointer} Machine" is many things. Authors who consider referring to this term are invited to read the following note first. 1 Introduction  In a 1992 paper by Galil and the author we referred to a "pointer machine " model of computation. A subsequent survey of related literature has produced over twenty references to papers having to do with "pointer machines", naturally containing a large number of cross-references. These papers address a range of subjects that range from the model considered in the above paper to some other ones which are barely comparable. The fact that such different notions have been discussed under the heading of "pointer machines" has produced the regrettable effect that cross references are sometimes found to be misleading. Clearly, it is easy for a reader who does not follow a paper carefully to misinterpret its claims when a term that is so ill-defined is used. This note is an attempt to rectify the situation. We start with a survey of the different notions...},
	booktitle = {Science of Computer Programming},
	publisher = {American Mathematical Society},
	author = {Ben-amram, Amir M.},
	year = {1995}
},

@inproceedings{schopp_space-efficient_2006,
	title = {Space-Efficient Computation by Interaction},
	url = {http://dblp.uni-trier.de/rec/bibtex/conf/csl/Schopp06},
	urldate = {2014-01-30},
	author = {Sch\"opp, Ulrich},
	year = {2006},
	pages = {606--621}
}

@article{Itai1987,
	author	=	{Itai, Alon and Makowsky, Johann A.},
	title		=	{Unification as a Complexity Measure for Logic Programming},
	journal	=	{J. Log. Program.},
	volume	=	{4},
	number	=	{2},
	year		=	{1987},
	pages	=	{105--117},
	doi		=	{10.1016/0743-1066(87)90014-8}
}
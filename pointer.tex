To prove the converse of theorem \ref{soundness}, we introduce a notion of pointer machine that can easily be encoded as wirings.
Apart from the result, this also provides a way of seeing how wiring are computing.

Pointer machines \cite{ben-amram_what_1995} are theoretical devices that aim at modelling computation in a way that varies from turing machines: the data is a read-only sequence of symbols, and there is no memory tape. Instead, the machine manipulates pointers to various point of the input.

\define[pointer machine]
{A pointer machine over an alphabet $\,\Sigma\,$ is a tuple $\,(N,\TT S,\Delta)\,$ where
\begin{itemize}
	\item $N\neq 0\,$ is an integer, the \emph{number of pointers}
	\item $\TT S\,$ is a finite set, the \emph{states} of the machine
	\item $\Delta \,\subseteq\, (\TT S\times\Sigma\times\IO)\times(\TT S\times\Sigma\times\IO)\times \F S_N\:$, the \emph{transitions} of the machine 
	
	(we will write $\,(s,\TT c,\TT d) \rightarrow (s',\TT c',\TT d') \times \sigma\,$ the transitions, for readability)
\end{itemize}
A pointer machine will be called \emph{deterministic} if for any $\,A \,\in\, \TT S\times \Sigma\times \IO\,$, there is at most one $\,B\,\in\, \TT S\times \Sigma\times \IO\,$ and one $\,\sigma\in \F S_n\,$ such that $\,A\rightarrow B \times \sigma\,\in\,\Delta\,$.
In that case we can see $\,\Delta\,$ as a partial function, and we say that $\,M\,$ is \emph{reversible} if $\,\Delta\,$ is a partial injection.
}

\define[configuration]
{Given an input word $\,w\,$ of length $\,n\,$ and a pointer machine $\,M=(N,\TT S,\Delta)\,$, a \emph{configuration} of $\,(M,w)\,$ is an element of 
\[\,\TT S\times\Sigma\times\IO\times\{0,1,\dots,n\}^N\,\]}

Let us explain the intuitive meaning of a configuration. We call the first of the $\,N\,$ pointers the \emph{main} pointer which has a distinguished behaviour.
The other pointers are refered to as the \emph{auxiliairy} pointers

The element of $\,\TT S\,$ is the state the machine is in.
The element of $\,\Sigma\,$ is the letter the main pointer points at, the element of $\,\IO\,$ is the direction of the next move of the main pointer, and the element of $\,\{0,1,\dots,n\}^N\,$ correspond to the positions of the pointers on the input.

\smallskip
As the input tape is considered cyclic with a special symbol marking the beginning of the word, the pointer positions are integers \emph{modulo} $\,n+1\,$ for an input word of length $\,n\,$.

\define[transition]
{Let $\,w\,$ be a word and $\,M=(N,\TT S,\Delta)\,$ be a pointer machine. A \emph{transition} of $\,(w,M)\,$
is a triple of configurations
\[s,\TT c,\TT d,(p_1,\dots,p_N) \trans{\TT{MOVE}}{} s,\TT c',\overline{\TT d},(p_1',\dots,p_N') \trans{\TT{SWAP}}{} s',\TT c'',\TT d',(p_{\sigma(1)}',\dots,p_{\sigma(N)}') \]
such that
\begin{itemize}
	\item if $\,\TT d\in\IO\,$, $\,\overline{\TT d}\,$ is the other element of $\,\IO\,$
	\item $p_1'=p_1+1\,$ if $\,\TT d=\i\,$ and $\,p_1'=p_1-1\,$ if $\,\TT d=\o\,$
	\item $p_i'=p_i\,$ for $\,i\neq 1\,$
	\item $\TT c\,$ is the letter at position $\,p_1\,$ and $\,\TT c'\,$ is the letter at position $\,p_1'\,$
	\item $(s,\TT c',\overline{\TT d}) \rightarrow (s',\TT c'',\TT d') \times \sigma\,$ belongs to $\,\Delta\,$
\end{itemize}
}

Note that the maintenance of $\,\TT c''\,$ as the letter pointed to by the (new) main pointer is not required at the \texttt{SWAP} phase, which will cause most computation to stop unexpectedly.
The point is that it is possible to implement that maintainance using the states of the machine (typically, add a store for the values of the pointers, which has finitely many configurations, to the state of the machine), and therefore we favor the simpler and more liberal definition.

\define[acceptation]
{\label{translate}We say that a pointer machine $\,M\,$ accepts the word $\,w\,$ if any sequence of transitions $\,\big(C_i\trans{\TT{MOVE}}{}C_i'\trans{\TT{SWAP}}{}C_i''\big)\,$ of $\,(w,M)\,$ such that $\,C''_i=C_{i+1}\,$ for all $\,i\,$ is necessarily finite.

We write $\,\lang(M)\,$ the set of words accepted by $\,M\,$.}

This means informally that we consider that a pointer machine accepts a word if it cannot ever loop, from whatever configuration it starts from.
Of course, this rather unusual acceptance condition is given with the acceptance condition of wirings in mind: nilpotency.

\define[machines and wirings]
{Let $\,M=(N,\TT S,\Delta)\,$ be a pointer machine.
We associate to the $\,s\in \TT S\,$ a set of distinct closed terms $\,[\TT S]\,$. We write $\,[s]\,$ the term associated to $\,s\,$.

To any element $\,D=(s,\TT c,\TT d) \rightarrow (s',\TT c',\TT d') \times \sigma\,$ of $\,\Delta\,$ we associate the flow 
\[[D]:=([s']\p\TT c'\p\TT d' \flow [s]\p\TT c\p\TT d) \tensor \sigma \:\in[\TT S]\tensor\Sigma\tensor\IO\tensor\C S_n\,\]

and we define the wiring $\,[M]\in\C O_\Sigma^+\,$ as $\,\displaystyle\sum_{D\in \Delta} [D]\,$.
}

This translation preserves the language recognized and relates reversibility with isometricity.

\theorem[reversibility]
{A pointer machine $\,M\,$ is reversible if and only if $\,[M]\,$ is an isometric wiring.}

\theorem[acceptation]
{For any pointer machine $\,M\,$, $\,\lang(M)=\lang([M])\,$.}


It turns out that pointer machines are expressive enough to solve any \textsc{(N)Logspace} problem, we get the result we aim at.

\theorem[space completeness]
{If $\,L\in \text{\sc NLogspace}\,$, then there exist a pointer machine $\,M\,$ such that $\,\lang(M)=L\,$.
Moreover, if $\,L\in \text{\sc Logspace}\,$ then $\,M\,$ can be chosen to be reversible.
}

\proof{The proof of this fact is a matter of encoding, along the lines of the corresponding proofs in \cite{aubert_characterizing_2012,seiller_logarithmic_2013}.}
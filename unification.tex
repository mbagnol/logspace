Unification can be generally thought of the study of formal solving of equations between terms.

This topic was introduced by Herbrand in his thesis \cite{herbrand_recherches_1930}, but became really widespread after the work of J.~A.~Robinson on automated theorem proving \cite{robinson_machine-oriented_1965}. The unification technique is also at the core of the logic programming language \textsc{Prolog} and type inference for functional programming languages such as \textsc{CaML} and \textsc{Haskell}.

%\subsubsection*{Terms and substitutions}

Specifically, we will be interested in the following problem: 
\begin{center}
	\it Given two (first-order) terms,\\ can they be “made equal” by replacing their variables?
\end{center}

To make more things concrete, we set a specific set of terms for the rest of this article.


\define[terms]
	{We consider the following set of first-order terms
	
	$$\terms::=\ \ x,y,z,\:\dots\ |\ \TT a,\tt b,\tt c,\:\dots\ |\ \terms\p\terms $$
	
	where  $\,x,y,z,\:\dots\in \vars\,$ are variables and $\,\TT a,\TT b,\TT c,\:\dots\,$ are constants, while $\,\p\,$ is a binary function symbol.

\smallskip
For any $\,t\in\terms\,$, we will write $\,\var(t)\,$ the set of variables occuring in $\,t\,$. We say that a term is closed whenever $\,\var(t)=\varnothing\,$, and denote the set of closed terms as $\,\closed\,$. 
}

\notation{We will write the binary function symbol as \emph{right associating} to avoid an excess of parenthesis: $$\,t\p u\p v \::=\:t\p(u\p v) \,$$}
%We also leave the $\,\p\,$ implicit $\,\TT c\p u\,$, so that: $\,\TT{lrc}\p\TT{llc}:=(\TT l \p\TT r \p\TT c)\p \TT l \p\TT l \p\TT c=(\TT l \p(\TT r \p\TT c))\p (\TT l \p(\TT l \p\TT c))\,$}

%Variables in terms are meant to be replaced when needed by a term of the language. This is implemented by the notion of substitution.

\define[substitution]
	{A substitution if a map $\,\theta:\:\vars \rightarrow \terms\,$ such that the set $\,\dom(\theta):=\{\:v\in \vars\:|\:\theta(v)\not=v\:\}\,$ (the \emph{domain} of $\,\theta\,$) is finite. A substitution with domain $\,\{\:x_1,\dots,x_n\:\}\,$ such that $\;\theta(x_1)=u_1\,,\,\dots\,,\,\theta(x_n)=u_n\;$ can therefore be written as $\,\{\:x_1\mapsto u_1\,;\,\dots\,;\, x_n\mapsto u_n\:\}\,$.

\smallskip
	If $\,t\in \terms\,$ is a term we write $\,t.\theta\,$ the term $\,t\,$ where any occurence of any variable $\,x\,$ has been replaced by $\,\theta(x)\,$.
	
	\smallskip
	If $\,\theta=\{\:x_i\mapsto u_i\:\}$ and $\,\psi=\{\:y_j\mapsto v_j\:\}\,$, their \emph{composition} is defined as
$$\theta;\psi\::=\: 
	\{\:x_i\mapsto u_i.\psi\:\} \:\cup\:
	\{\:y_i\mapsto v_i \:|\;y_i \not\in \dom(\theta)\:\}$$
\vspace{-5mm}
}

\remark{The composition of substitutions is such that $\,t.(\theta;\psi)=(t.\theta).\psi\,$ holds.}



\define[vocabulary]
	{A \emph{renaming} is a substitution $\,\alpha\,$ such that $\,\alpha(\vars)\subseteq \vars\,$ and that is bijective.

\smallskip Two substitutions $\,\theta,\psi\,$ are equal \emph{up to renaming} if there exist a renaming $\,\alpha\,$ such that $\,\psi=\theta;\alpha\,$. Two terms $\,t,u\,$ are equal \emph{up to renaming} if there exist a renaming $\,\alpha\,$ such that $\,t=u.\alpha\,$.

\smallskip A substitution $\,\psi\,$ is an \emph{instance} of $\,\theta\,$ if there exists a substitution $\,\sigma\,$ such that $\,\psi=\theta;\sigma\,$.

\smallskip A substitution $\,\theta\,$ is \emph{idempotent} if $\,\theta;\theta=\theta\,$.
}

\theorem%[folklore]
	{\label{folklore}The following properties hold for any substitutions $\,\theta,\psi\,$:
	\begin{itemize}%[parsep=0pt]
		\item The only invertible substitutions are renamings.
		\item Every substitution is equal up to renaming to an idempotent substitution.
		\item If $\,\theta\,$ is an instance of $\,\psi\,$ and $\,\psi\,$ is an instance of $\,\theta\,$, then they are equal up to renaming.
	\end{itemize}
}

%\subsubsection*{Unification problems}

To allow easier manipulation, the problem of unifying \emph{two} terms needs to be generalized into the problem of simultaneously unifying several pairs of terms.

\define[unification]
	{A \emph{unification problem} is finite set of pair of terms $\,P=\{\:t_i\uequ u_i\:\}\,$.
	
	It is said to be unifiable if it has a \emph{unifier}: a substitution $\,\theta\,$ such that 
	$$u_i.\theta=t_i.\theta\ \text{ for all }\,i$$
	$\theta\,$ is a \emph{most general unifier (MGU) of $\,P\,$} if any other unifier of $\,P\,$ is an instance of~$\,\theta\,$.
	
	\smallskip
	In particular, we say that two terms $\,t,u\,$ are \emph{unifiable} if there exists a substitution $\,\theta\,$ such that
	$$t.\theta=u.\theta$$
	\vspace{-5mm}
}

\remark{It follows from proposition \ref{folklore} that any two MGU of the same unification problem are equal up to renaming.}

\smallskip
We will be interested mostly in the weaker variant of unification where one can first rename terms so that they variables are distinct, we introduce therefore a specific vocabulary for it.

\define[disjointness and matching]
	{\label{disjoint}Two terms $\,t,u\,$ are \emph{matchable} if $\,t',u'\,$ are unifiable, where $\,t',u'\,$ are renamings of $\,t,u\,$ such that $\,\var(t')\cap\var(u')=\varnothing\,$.
	
	If two terms are not matchable, they are said to be \emph{disjoint}.
}

\example{$x\,$ and $\,\TT f\p x\,$ are not unifiable. However they are matchable, as $\,x.\{\,x\mapsto y\,;\,y\mapsto x\,\}=y\,$ which is unifiable with $\,\TT f\p x\,$.

More generally, disjointness is stronger than non-unifyability.}

\medskip
The crucial feature of first-order unification is the (decidable) existence of most general unifiers for unification problems that have a solution.

\theorem[MGU]
{If a unification problem has a unifier, then it has a MGU.

Wether two terms are unifiable and, in case they are, finding a MGU is decidable.}


We can determine if a unification problem has a solution. We note the following fact, that will be useful in the next section: solving a unification problem can be done incrementally.

\smallskip
\notation{If $\,P=\{\:t_i\uequ u_i\:\}\,$ is a unification problem and $\,\theta\,$ a substitution, we write $$\,P.\theta:=\{\:t_i.\theta\uequ u_i.\theta\:\}\,$$}

\lemma[partial unification]
	{\label{part-unif}Let $\,P=Q\uplus R\,$ ($\,\uplus\,$ denotes disjoint union) be a unification problem. The following statements are equivalent:
	\begin{itemize}
		\item $\,P\,$ is unifiable
		\item $\,Q\,$ is unifiable with MGU $\,\theta\,$ and $\,R.\theta\,$ is unifiable with MGU $\,\psi\,$
	\end{itemize}
In that case, we have moreover that $\,\theta;\psi\,$ is a MGU of $\,P\,$.
}

%\proof{The algorithm from the above proof can be modified to treat first pairs of $\,Q\,$ at line 3 without affecting its behaviour. 
%}

%\subsubsection*{Complexity of unification}

%Herbrand's original procedure for solving unification was non-deterministic.

J.~A.~Robinson was the first to prove the existence of MGU for two unifiable terms and derived from this a deterministic unification procedure.%, basically the one we presented in the previous sub-section. 
His procedure is however quite inefficient, with potential exponential blowups in some cases. 

\smallskip
It turns out that the general unification problem can be solved in linear time, which was discovered independently in \cite{paterson_linear_1978} and \cite{martelli_unification_1976}, improving on the almost-linear algorithm thus far designed.

\smallskip
Unification was first thought to be a \textsc{NLogspace}-complete problem. However, an error was eventually found in the note \cite{lewis_unifiability_1982} claiming this fact, which eventually led to a determination of the intrinsic complexity of the problem: unification is indeed \textsc{Ptime}-complete under logarithmic space reductions \cite{dwork_sequential_1984}.

\medskip
In this article, we are concerned with a very much simpler case of the problem: the matching (definition \ref{disjoint}) of linear terms (\textit{ie.} where variables occur at most once). This case can be solved in a space-efficient way.

\theorem[logarithmic space {\cite[lemma 20]{dwork_parallel_1988}}]
{\label{unif-logspace}Wether two linear terms $\,t,u\,$ with disjoint sets of variables are unifiable, and if so finding a MGU, can be computed in logarithmic space on a deterministic Turing machine.

\smallskip
Moreover, their MGU is of size at most the sum of the sizes of $\,t\,$ and $\,u\,$.
}

Actually, the lemma in the article states that the problem is in \textsc{NC}\up 1, a complexity class of parallel computations known to be included in \textsc{Logspace}.

